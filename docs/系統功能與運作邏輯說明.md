# 碳排放交易實驗平台系統功能與運作邏輯說明

**版本**：3.0  
**最後更新**：2025 年 6 月 27 日  
**實驗平台**：oTree 5.10.0+  

---

## 目錄

1. [系統概述](#系統概述)
2. [通用架構與流程](#通用架構與流程)
3. [對照組 (Control)](#對照組-control)
4. [碳稅組 (Carbon Tax)](#碳稅組-carbon-tax)
5. [MUDA 訓練組](#muda-訓練組)
6. [碳交易組 (Carbon Trading)](#碳交易組-carbon-trading)
7. [共用工具函數](#共用工具函數)
8. [配置管理系統](#配置管理系統)
9. [數據流與狀態管理](#數據流與狀態管理)

---

## 系統概述

### 平台架構
本實驗平台基於 oTree 框架開發，採用模組化設計，支援四種不同的實驗處理組別：

- **對照組 (Stage_Control)**：基準實驗，無碳排放政策
- **碳稅組 (Stage_CarbonTax)**：碳排放徵收稅金政策
- **MUDA 訓練組 (Stage_MUDA)**：純交易練習系統
- **碳交易組 (Stage_CarbonTrading)**：結合生產決策與碳權交易

### 核心技術特色
- **即時交易系統**：使用 WebSocket 技術實現即時撮合
- **智慧配置管理**：YAML 配置檔案支援動態參數調整
- **完整數據追蹤**：記錄所有決策、交易和市場動態
- **測試模式支援**：可快速切換正式模式與測試模式

---

## 通用架構與流程

### 基本實驗流程

```pseudocode
EXPERIMENT_FLOW:
    FOR round = 1 TO num_rounds:
        1. 初始化階段 (Initialize)
        2. 介紹頁面 (Introduction, 僅第一回合)
        3. 等待頁面 (ReadyWaitPage)
        4. 主要實驗頁面 (根據組別不同)
        5. 結果等待頁面 (ResultsWaitPage)
        6. 結果顯示頁面 (Results)
    END FOR
    
    計算最終報酬 (基於隨機選中的一個回合)
```

### 玩家角色初始化

```pseudocode
INITIALIZE_PLAYER_ROLES(subsession, initial_capital):
    num_players = 玩家總數
    num_dominant = 配置檔案中的主導廠商數量
    
    IF 測試模式 AND ensure_player1_dominant:
        roles[0] = True  // 確保1號玩家為主導廠商
        隨機分配其餘主導廠商
    ELSE:
        隨機分配所有主導廠商
    END IF
    
    FOR each player:
        player.is_dominant = roles[player_index]
        
        IF player.is_dominant:
            player.marginal_cost_coefficient = random(1, 5)
            player.carbon_emission_per_unit = 2.0
            player.max_production = 20
        ELSE:
            player.marginal_cost_coefficient = random(2, 7)
            player.carbon_emission_per_unit = 1.0
            player.max_production = 8
        END IF
        
        player.market_price = 隨機抽取市場價格()
        player.initial_capital = initial_capital
        player.current_cash = initial_capital
    END FOR
```

### 成本計算核心邏輯

```pseudocode
CALCULATE_PRODUCTION_COST(player, production_quantity):
    IF production_quantity <= 0:
        RETURN 0.0
    END IF
    
    // 使用固定種子確保一致性
    random.seed(player.id_in_group * 1000 + player.round_number)
    
    total_cost = 0.0
    FOR i = 1 TO production_quantity:
        unit_marginal_cost = player.marginal_cost_coefficient * i
        unit_disturbance = random.uniform(-1, 1)
        total_cost += unit_marginal_cost + unit_disturbance
    END FOR
    
    random.seed()  // 重置隨機種子
    RETURN total_cost
```

---

## 對照組 (Control)

### 功能概述
對照組提供基準實驗環境，參與者只需進行生產決策，不受任何碳排放政策限制。

### 頁面流程

```pseudocode
CONTROL_STAGE_FLOW:
    1. Introduction (僅第一回合)
       - 顯示實驗說明
       - 介紹成本結構和市場機制
    
    2. ReadyWaitPage
       - 等待所有玩家準備完成
       - 執行角色初始化
    
    3. ProductionDecision
       - 玩家輸入生產量 (0 到 max_production)
       - 即時計算並顯示：
         * 預期收益 = 生產量 × 市場價格
         * 預期成本 = 累加邊際成本函數
         * 預期利潤 = 收益 - 成本
    
    4. ResultsWaitPage
       - 等待所有玩家完成決策
       - 執行利潤計算
    
    5. Results
       - 顯示本回合結果
       - 顯示群組總排放量
       - 如果是最後回合，顯示最終報酬資訊
```

### 核心運算邏輯

```pseudocode
CONTROL_PAYOFF_CALCULATION(group):
    FOR each player IN group:
        IF player.production IS NULL:
            player.production = 0
        END IF
        
        cost = CALCULATE_PRODUCTION_COST(player, player.production)
        revenue = player.production * player.market_price
        profit = revenue - cost
        
        player.revenue = revenue
        player.total_cost = cost
        player.net_profit = profit
        player.final_cash = player.current_cash + profit
        player.payoff = profit
    END FOR
```

### 前端互動邏輯

```javascript
// ProductionDecision.html 中的核心 JavaScript
function updateCalculations() {
    const production = parseInt(document.getElementById('id_production').value) || 0;
    
    // 計算收益
    const revenue = production * marketPrice;
    
    // 計算成本（與後端邏輯一致）
    let totalCost = 0;
    for (let i = 1; i <= production; i++) {
        const unitMarginalCost = marginalCostCoefficient * i;
        const unitDisturbance = disturbanceValues[i-1] || 0;
        totalCost += unitMarginalCost + unitDisturbance;
    }
    
    // 計算利潤
    const profit = revenue - totalCost;
    
    // 更新顯示
    updateDisplay(revenue, totalCost, profit);
}
```

---

## 碳稅組 (Carbon Tax)

### 功能概述
碳稅組在對照組基礎上增加碳稅機制，根據碳排放量徵收稅金，研究碳稅政策對生產行為的影響。

### 頁面流程

```pseudocode
CARBON_TAX_STAGE_FLOW:
    1. 初始化階段
       - 從配置檔案隨機選擇碳稅率
       - 儲存稅率到 subsession.tax_rate
    
    2. Introduction (僅第一回合)
       - 顯示碳稅政策說明
       - 說明稅額計算方式
    
    3. ProductionDecision
       - 玩家輸入生產量
       - 即時計算並顯示：
         * 碳排放量 = 生產量 × 每單位排放量
         * 碳稅總額 = 碳排放量 × 稅率
         * 預期利潤 = 收益 - 成本 - 碳稅
    
    4. Results
       - 顯示包含碳稅的完整結果
```

### 核心運算邏輯

```pseudocode
CARBON_TAX_INITIALIZATION(subsession):
    tax_rates = 配置檔案中的稅率選項  // [1, 2, 3]
    selected_tax_rate = random.choice(tax_rates)
    subsession.tax_rate = selected_tax_rate
    
    // 儲存到 session 變數以便跨頁面存取
    subsession.session.vars[f'tax_rate_round_{subsession.round_number}'] = selected_tax_rate

CARBON_TAX_PAYOFF_CALCULATION(group):
    FOR each player IN group:
        cost = CALCULATE_PRODUCTION_COST(player, player.production)
        revenue = player.production * player.market_price
        emissions = player.production * player.carbon_emission_per_unit
        tax = emissions * player.subsession.tax_rate
        profit = revenue - cost - tax
        
        player.revenue = revenue
        player.total_cost = cost
        player.carbon_tax_paid = tax
        player.net_profit = profit
        player.final_cash = player.current_cash + profit
        player.payoff = profit
    END FOR
```

### 前端稅額計算

```javascript
// ProductionDecision.html 中的碳稅計算
function updateTaxCalculations() {
    const production = parseInt(document.getElementById('id_production').value) || 0;
    
    // 基本計算
    const revenue = production * marketPrice;
    const totalCost = calculateProductionCost(production);
    
    // 碳稅計算
    const totalEmissions = production * carbonEmissionPerUnit;
    const carbonTax = totalEmissions * taxRate;
    
    // 稅後利潤
    const netProfit = revenue - totalCost - carbonTax;
    
    // 更新顯示
    updateTaxDisplay(revenue, totalCost, carbonTax, netProfit, totalEmissions);
}
```

---

## MUDA 訓練組

### 功能概述
MUDA 組提供純交易練習環境，讓參與者熟悉交易系統操作，不涉及生產決策。

### 頁面流程

```pseudocode
MUDA_STAGE_FLOW:
    1. 初始化階段
       - 設定參考碳權價格
       - 為每個玩家分配初始現金和碳權
       - 設定個人碳權估值（創造交易動機）
    
    2. Introduction (僅第一回合)
       - 說明交易規則和介面操作
    
    3. TradingMarket (限時交易)
       - 即時買賣碳權交易
       - 自動撮合系統
       - 交易歷史記錄
    
    4. Results
       - 顯示交易統計
       - 計算總資產價值（現金 + 碳權價值）
```

### 初始化邏輯

```pseudocode
MUDA_INITIALIZATION(subsession):
    // 設定參考價格
    reference_price = random.choice(配置檔案中的價格選項)
    subsession.item_market_price = reference_price
    subsession.start_time = current_timestamp()
    
    FOR each player:
        // 現金管理
        IF 重置現金模式 OR 第一回合:
            player.current_cash = INITIAL_CAPITAL
        ELSE:
            player.current_cash = 上一回合的最終現金
        END IF
        
        player.initial_capital = player.current_cash
        
        // 隨機分配初始碳權
        player.current_items = random.randint(3, 8)
        
        // 設定個人碳權估值（創造交易動機）
        player.personal_item_value = random.choice(價格選項)
        
        // 初始化交易統計
        player.total_bought = 0
        player.total_sold = 0
        player.total_spent = 0
        player.total_earned = 0
    END FOR
```

### 即時交易系統

```pseudocode
MUDA_LIVE_TRADING_METHOD(player, data):
    group = player.group
    
    // 載入現有訂單
    buy_orders = JSON.parse(group.buy_orders)
    sell_orders = JSON.parse(group.sell_orders)
    
    IF data.type == 'place_order':
        direction = data.direction  // 'buy' or 'sell'
        price = data.price
        quantity = data.quantity
        
        // 驗證訂單
        IF direction == 'buy':
            // 移除現金檢查，允許負債購買
            // 自動取消玩家之前的買單
            CANCEL_PLAYER_ORDERS(group, player.id, 'buy')
            
            // 尋找匹配的賣單
            matching_sells = FIND_MATCHING_SELLS(sell_orders, player.id, price, quantity)
            
            IF matching_sells 存在:
                best_sell = 選擇最低價格的賣單
                EXECUTE_TRADE(player, seller, best_sell.price, quantity)
                REMOVE_ORDER(sell_orders, best_sell)
            ELSE:
                ADD_ORDER(buy_orders, [player.id, price, quantity])
            END IF
            
        ELSE IF direction == 'sell':
            // 檢查單次賣單不超過持有量
            IF quantity > player.current_items:
                RETURN error_message
            END IF
            
            // 自動取消玩家之前的賣單
            CANCEL_PLAYER_ORDERS(group, player.id, 'sell')
            
            // 尋找匹配的買單
            matching_buys = FIND_MATCHING_BUYS(buy_orders, player.id, price, quantity)
            
            IF matching_buys 存在:
                best_buy = 選擇最高價格的買單
                EXECUTE_TRADE(buyer, player, best_buy.price, quantity)
                REMOVE_ORDER(buy_orders, best_buy)
            ELSE:
                ADD_ORDER(sell_orders, [player.id, price, quantity])
            END IF
        END IF
        
        // 廣播市場狀態更新
        BROADCAST_MARKET_STATE(group)
        
    ELSE IF data.type == 'accept_offer':
        // 處理接受現有掛單的邏輯
        PROCESS_ACCEPT_OFFER(player, data)
    END IF
    
    RETURN market_state_for_all_players
```

### 交易執行邏輯

```pseudocode
EXECUTE_TRADE(buyer, seller, price, quantity):
    // 更新現金和碳權
    buyer.current_cash -= price * quantity
    seller.current_cash += price * quantity
    buyer.current_items += quantity
    seller.current_items -= quantity
    
    // 更新交易統計
    buyer.total_bought += quantity
    buyer.total_spent += price * quantity
    seller.total_sold += quantity
    seller.total_earned += price * quantity
    
    // 記錄交易歷史
    RECORD_TRADE(group, buyer.id, seller.id, price, quantity)
    
    // 自動取消相關訂單
    CANCEL_PLAYER_ORDERS(group, buyer.id, 'buy')
    CANCEL_PLAYER_ORDERS(group, seller.id, 'sell')
```

### 最終結算邏輯

```pseudocode
MUDA_SET_PAYOFFS(group):
    FOR each player IN group:
        // 計算碳權價值（使用個人估值）
        player.item_value = player.current_items * player.personal_item_value
        
        // 計算總資產價值
        player.total_value = player.current_cash + player.item_value
        
        // 記錄最終現金
        player.final_cash = player.current_cash
        
        // 計算利潤
        profit = player.total_value - player.initial_capital
        player.payoff = profit
    END FOR
```

---

## 碳交易組 (Carbon Trading)

### 功能概述
碳交易組是最複雜的實驗組別，結合即時碳權交易和生產決策，研究碳權交易市場的效率和影響。

### 頁面流程

```pseudocode
CARBON_TRADING_STAGE_FLOW:
    1. 初始化階段
       - 計算社會最適產量和排放量
       - 動態分配碳權配額
       - 設定市場價格
    
    2. Introduction (僅第一回合)
       - 說明碳交易規則
    
    3. TradingMarket (限時交易)
       - 即時碳權買賣交易
       - 自動撮合系統
       - 交易統計追蹤
    
    4. ProductionDecision
       - 基於碳權持有量決定生產量
       - 受碳權約束的生產決策
    
    5. Results
       - 顯示交易和生產結果
       - 計算最終資產價值
```

### 社會最適產量計算

```pseudocode
CALCULATE_OPTIMAL_ALLOWANCE_ALLOCATION(players, market_price):
    p = market_price  // 市場價格
    c = 社會碳成本  // 每單位碳的社會成本
    firm_details = []
    TE_opts = []
    
    // 計算每家廠商的社會最適產量
    FOR each player:
        a_i = player.marginal_cost_coefficient
        b_i = player.carbon_emission_per_unit
        
        // 社會最適產量：q_opt_i = (p - b_i * c) / a_i
        q_opt_i = (p - b_i * c) / a_i
        
        // 最適排放量：TE_opt_i = b_i * q_opt_i
        TE_opt_i = b_i * q_opt_i
        
        firm_details.append({
            'a': a_i,
            'b': b_i,
            'q_opt': q_opt_i,
            'TE_opt': TE_opt_i
        })
        
        TE_opts.append(TE_opt_i)
    END FOR
    
    // 社會最適排放總量
    TE_opt_total = sum(TE_opts)
    
    // 隨機選擇配額倍率
    r = random.choice(配置檔案中的倍率選項)  // [0.8, 1.0, 1.2]
    
    // 計算總配額
    cap_total = round(r * TE_opt_total)
    
    // 平均分配碳權
    N = 玩家數量
    base_allocation = cap_total // N
    remainder = cap_total % N
    
    allocations = [base_allocation] * N
    
    // 隨機分配剩餘配額
    IF remainder > 0:
        lucky_indices = random.sample(range(N), remainder)
        FOR each lucky_index:
            allocations[lucky_index] += 1
        END FOR
    END IF
    
    RETURN {
        'firm_details': firm_details,
        'TE_opt_total': TE_opt_total,
        'r': r,
        'cap_total': cap_total,
        'allocations': allocations
    }
```

### 碳交易系統

```pseudocode
CARBON_TRADING_LIVE_METHOD(player, data):
    group = player.group
    
    // 載入訂單
    buy_orders = JSON.parse(group.buy_orders)
    sell_orders = JSON.parse(group.sell_orders)
    
    IF data.type == 'submit_offer':
        direction = data.direction
        price = data.price
        quantity = data.quantity
        
        // 記錄玩家提交的掛單
        RECORD_SUBMITTED_OFFER(player, direction, price, quantity)
        
        IF direction == 'buy':
            // 移除現金檢查，允許負債購買
            CANCEL_PLAYER_ORDERS(group, player.id, 'buy')
            
            // 尋找匹配賣單
            available_sells = FILTER_SELLS(sell_orders, player.id, price, quantity)
            
            IF available_sells 存在:
                best_sell = SELECT_LOWEST_PRICE_SELL(available_sells)
                EXECUTE_CARBON_TRADE(player, seller, best_sell.price, quantity)
                REMOVE_SELL_ORDER(sell_orders, best_sell)
            ELSE:
                ADD_BUY_ORDER(buy_orders, [player.id, price, quantity])
            END IF
            
        ELSE IF direction == 'sell':
            // 檢查單次賣單不超過持有量
            IF quantity > player.current_permits:
                RETURN error_message
            END IF
            
            CANCEL_PLAYER_ORDERS(group, player.id, 'sell')
            
            // 尋找匹配買單
            available_buys = FILTER_BUYS(buy_orders, player.id, price, quantity)
            
            IF available_buys 存在:
                best_buy = SELECT_HIGHEST_PRICE_BUY(available_buys)
                EXECUTE_CARBON_TRADE(buyer, player, best_buy.price, quantity)
                REMOVE_BUY_ORDER(buy_orders, best_buy)
            ELSE:
                ADD_SELL_ORDER(sell_orders, [player.id, price, quantity])
            END IF
        END IF
        
        BROADCAST_MARKET_STATE(group)
    END IF
    
    RETURN market_state_for_all_players
```

### 生產決策約束

```pseudocode
CARBON_TRADING_PRODUCTION_DECISION(player, values):
    production = values['production']
    
    // 檢查碳權約束
    required_permits = production * player.carbon_emission_per_unit
    
    IF required_permits > player.current_permits:
        RETURN error_message("生產量超過碳權限制")
    END IF
    
    // 檢查生產能力約束
    IF production > player.max_production:
        RETURN error_message("生產量超過最大生產能力")
    END IF
    
    RETURN None  // 無錯誤
```

### 前端生產約束計算

```javascript
// ProductionDecision.html 中的約束計算
function updateProductionConstraints() {
    const maxByCapacity = maxProduction;
    const maxByPermits = Math.floor(currentPermits / carbonEmissionPerUnit);
    const actualMaxProduction = Math.min(maxByCapacity, maxByPermits);
    
    // 更新輸入框最大值
    document.getElementById('id_production').max = actualMaxProduction;
    
    // 顯示約束資訊
    updateConstraintDisplay(maxByCapacity, maxByPermits, actualMaxProduction);
}
```

### 最終結算邏輯

```pseudocode
CARBON_TRADING_SET_PAYOFFS(group):
    FOR each player IN group:
        IF player.production IS NULL:
            player.production = 0
        END IF
        
        // 計算生產成本（與前端一致的邏輯）
        cost = CALCULATE_PRODUCTION_COST_WITH_DISTURBANCE(player)
        revenue = player.production * player.market_price
        
        // 計算最終現金（扣除生產成本後）
        final_cash_after_production = player.current_cash - cost
        
        // 計算總資產價值（現金 + 生產收入）
        total_final_value = final_cash_after_production + revenue
        
        // 利潤 = 總資產價值 - 初始資金
        profit = total_final_value - player.initial_capital
        
        player.revenue = revenue
        player.total_cost = cost
        player.net_profit = profit
        player.final_cash = final_cash_after_production + revenue
        player.payoff = profit
    END FOR
```

---

## 共用工具函數

### 價格歷史更新

```pseudocode
UPDATE_PRICE_HISTORY(subsession, trade_price, event='trade'):
    // 載入現有歷史
    price_history = JSON.parse(subsession.price_history)
    
    // 計算相對時間
    elapsed_seconds = current_time() - subsession.start_time
    minutes = elapsed_seconds // 60
    seconds = elapsed_seconds % 60
    
    // 創建價格記錄
    price_record = {
        'timestamp': f"{minutes:02d}:{seconds:02d}",
        'price': trade_price,
        'event': event,
        'market_price': subsession.market_price,
        'round': subsession.round_number
    }
    
    price_history.append(price_record)
    subsession.price_history = JSON.dumps(price_history)
    
    RETURN price_history
```

### 交易記錄函數

```pseudocode
RECORD_TRADE(group, buyer_id, seller_id, price, quantity):
    // 載入交易歷史
    trade_history = JSON.parse(group.trade_history)
    
    // 計算時間戳
    elapsed_seconds = current_time() - group.subsession.start_time
    minutes = elapsed_seconds // 60
    seconds = elapsed_seconds % 60
    
    // 創建交易記錄
    trade_record = {
        'timestamp': f"{minutes:02d}:{seconds:02d}",
        'buyer_id': buyer_id,
        'seller_id': seller_id,
        'price': price,
        'quantity': quantity,
        'total_value': price * quantity,
        'market_price': group.subsession.market_price
    }
    
    trade_history.append(trade_record)
    group.trade_history = JSON.dumps(trade_history)
    
    // 同時更新價格歷史
    UPDATE_PRICE_HISTORY(group.subsession, price)
    
    RETURN trade_history
```

### 訂單取消函數

```pseudocode
CANCEL_PLAYER_ORDERS(group, player_id, order_type):
    IF order_type == 'buy':
        buy_orders = JSON.parse(group.buy_orders)
        old_count = COUNT_PLAYER_ORDERS(buy_orders, player_id)
        buy_orders = FILTER_OUT_PLAYER_ORDERS(buy_orders, player_id)
        group.buy_orders = JSON.dumps(buy_orders)
        LOG(f"已取消玩家 {player_id} 的 {old_count} 筆買單")
        
    ELSE IF order_type == 'sell':
        sell_orders = JSON.parse(group.sell_orders)
        old_count = COUNT_PLAYER_ORDERS(sell_orders, player_id)
        sell_orders = FILTER_OUT_PLAYER_ORDERS(sell_orders, player_id)
        group.sell_orders = JSON.dumps(sell_orders)
        LOG(f"已取消玩家 {player_id} 的 {old_count} 筆賣單")
    END IF
```

---

## 配置管理系統

### 配置檔案結構

```yaml
# configs/experiment_config.yaml
general:
  players_per_group: 15
  num_rounds: 15
  
  dominant_firm:
    count: 3
    mc_range: [1, 5]
    emission_per_unit: 2
    max_production: 20
    
  non_dominant_firm:
    mc_range: [2, 7]
    emission_per_unit: 1
    max_production: 8

test_mode:
  enabled: false  # 測試模式開關
  players_per_group: 2
  num_rounds: 3
  dominant_firm:
    count: 1
  ensure_player1_dominant: true

stages:
  control:
    name_in_url: "control"
    initial_capital: 300
    
  carbon_tax:
    name_in_url: "carbon_tax"
    initial_capital: 300
    tax_rates: [1, 2, 3]
    
  muda:
    name_in_url: "muda"
    initial_capital: 10000
    trading_time: 30
    item_name: "碳權"
    
  carbon_trading:
    name_in_url: "carbon_trading"
    initial_capital: 10000
    trading_time: 120
    social_cost_per_unit_carbon: 5
    cap_multipliers: [0.8, 1.0, 1.2]
```

### 配置載入邏輯

```pseudocode
CONFIG_LOADING_LOGIC:
    // 載入基本配置
    base_config = LOAD_YAML('experiment_config.yaml')
    
    // 檢查測試模式
    IF base_config.test_mode.enabled:
        // 測試模式參數覆蓋正式參數
        FOR each test_mode_parameter:
            IF parameter EXISTS IN test_mode:
                config[parameter] = test_mode[parameter]
            ELSE:
                config[parameter] = general[parameter]
            END IF
        END FOR
        
        config.test_mode = True
        config.ensure_player1_dominant = test_mode.ensure_player1_dominant
    ELSE:
        config = general
        config.test_mode = False
    END IF
    
    RETURN config
```

---

## 數據流與狀態管理

### 玩家狀態追蹤

```pseudocode
PLAYER_STATE_TRACKING:
    // 基本狀態
    player.is_dominant: Boolean
    player.marginal_cost_coefficient: Integer
    player.carbon_emission_per_unit: Float
    player.max_production: Integer
    player.market_price: Currency
    
    // 財務狀態
    player.initial_capital: Currency
    player.current_cash: Currency
    player.final_cash: Currency
    
    // 決策狀態
    player.production: Integer
    player.revenue: Currency
    player.total_cost: Float
    player.net_profit: Float
    player.payoff: Float
    
    // 交易狀態（MUDA 和碳交易組）
    player.current_items/current_permits: Integer
    player.total_bought: Integer
    player.total_sold: Integer
    player.total_spent: Currency
    player.total_earned: Currency
    player.submitted_offers: JSON String
    
    // 最終報酬
    player.selected_round: Integer
```

### 群組狀態管理

```pseudocode
GROUP_STATE_MANAGEMENT:
    // 交易訂單（MUDA 和碳交易組）
    group.buy_orders: JSON String  // [[player_id, price, quantity], ...]
    group.sell_orders: JSON String  // [[player_id, price, quantity], ...]
    
    // 交易歷史
    group.trade_history: JSON String  // [trade_record, ...]
    
    // 市場狀態同步
    BROADCAST_MARKET_STATE(group):
        FOR each player IN group:
            market_state[player.id] = {
                'cash': player.current_cash,
                'items': player.current_items,
                'buy_orders': group.buy_orders,
                'sell_orders': group.sell_orders,
                'trade_history': group.trade_history,
                'notifications': player_specific_notifications
            }
        END FOR
        RETURN market_state
```

### 會話狀態管理

```pseudocode
SUBSESSION_STATE_MANAGEMENT:
    // 市場參數
    subsession.market_price: Currency
    subsession.tax_rate: Currency  // 僅碳稅組
    
    // 時間管理
    subsession.start_time: Integer  // Unix 時間戳
    
    // 價格歷史
    subsession.price_history: JSON String
    
    // 碳交易組特有
    subsession.total_optimal_emissions: Float
    subsession.cap_multiplier: Float
    subsession.cap_total: Integer
    subsession.allocation_details: JSON String
```

---

## 交接注意事項

### 關鍵配置檔案
1. `configs/experiment_config.yaml` - 主要實驗參數配置
2. `configs/config.py` - 配置載入和管理邏輯
3. `utils/shared_utils.py` - 共用函數庫

### 重要數據欄位
1. **玩家識別**：`id_in_group`, `is_dominant`
2. **財務追蹤**：`current_cash`, `final_cash`, `payoff`
3. **交易記錄**：`submitted_offers`, `total_bought`, `total_sold`
4. **最終報酬**：`selected_round` (隨機選中的回合)

### 測試模式切換
- 修改 `configs/experiment_config.yaml` 中的 `test_mode.enabled`
- 測試模式：2人、3回合、1個主導廠商
- 正式模式：15人、15回合、3個主導廠商

### 常見問題排查
1. **交易無法執行**：檢查 WebSocket 連線和 JSON 格式
2. **數據不一致**：確認前後端計算邏輯一致性
3. **角色分配錯誤**：檢查測試模式設定和隨機種子

---

**編制者**：Levi  
**聯絡方式**：請參考專案 README  
**版權**：MIT License  
**最後更新**：2025 年 6 月 27 日 